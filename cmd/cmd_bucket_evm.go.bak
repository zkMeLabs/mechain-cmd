package main

import (
	"context"
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/tx"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/ethclient"
	gnfdsdk "github.com/evmos/evmos/v12/sdk/types"
	"github.com/evmos/evmos/v12/x/evm/precompiles/storage"
	storagetypes "github.com/evmos/evmos/v12/x/storage/types"
	"github.com/rs/zerolog/log"
	"github.com/zkMeLabs/mechain-go-sdk/client"
	"github.com/zkMeLabs/mechain-go-sdk/types"
)

type EvmTXClient struct {
	cc *client.Client    // chain client
	ec *ethclient.Client // evm client
}

func NewTxClientEVM(cc *client.Client, ec *ethclient.Client) *EvmTXClient {
	return &EvmTXClient{cc, ec}
}

func (c *EvmTXClient) CreateBucket(ctx context.Context, bucketName string, primaryAddr string, opts types.CreateBucketOptions) (string, error) {
	address, err := sdk.AccAddressFromHexUnsafe(primaryAddr)
	if err != nil {
		return "", err
	}

	var visibility storagetypes.VisibilityType
	if opts.Visibility == storagetypes.VISIBILITY_TYPE_UNSPECIFIED {
		visibility = storagetypes.VISIBILITY_TYPE_PRIVATE // set default visibility type
	} else {
		visibility = opts.Visibility
	}

	var paymentAddr sdk.AccAddress
	if opts.PaymentAddress != "" {
		paymentAddr, err = sdk.AccAddressFromHexUnsafe(opts.PaymentAddress)
		if err != nil {
			return "", err
		}
	}

	createBucketMsg := storagetypes.NewMsgCreateBucket(c.cc.MustGetDefaultAccount().GetAddress(), bucketName, visibility, address, paymentAddr, 0, nil, opts.ChargedQuota)

	err = createBucketMsg.ValidateBasic()
	if err != nil {
		return "", err
	}

	accAddress, err := sdk.AccAddressFromHexUnsafe(primaryAddr)
	if err != nil {
		return "", err
	}

	sp, err := c.cc.GetStorageProviderInfo(ctx, accAddress)
	if err != nil {
		return "", err
	}

	familyID, err := c.cc.GetRecommendedVirtualGroupFamilyIDBySPID(ctx, sp.Id)
	if err != nil {
		log.Error().Msg(fmt.Sprintf("failed to query sp vgf:  %s", err.Error()))
		var signedMsg *storagetypes.MsgCreateBucket
		signedMsg, err = c.cc.GetCreateBucketApproval(ctx, createBucketMsg)
		if err != nil {
			return "", err
		}
		familyID = signedMsg.PrimarySpApproval.GlobalVirtualGroupFamilyId
	}

	createBucketMsg.PrimarySpApproval.GlobalVirtualGroupFamilyId = familyID

	// set the default txn broadcast mode as block mode
	if opts.TxOpts == nil {
		broadcastMode := tx.BroadcastMode_BROADCAST_MODE_SYNC
		opts.TxOpts = &gnfdsdk.TxOption{Mode: &broadcastMode}
	}

	nonce, err := c.cc.GetChainClient().GetNonce(ctx)
	if err != nil {
		return "", err
	}
	if opts.TxOpts != nil && opts.TxOpts.Nonce != 0 {
		nonce = opts.TxOpts.Nonce
	}
	chainId, err := c.ec.ChainID(ctx)
	if err != nil {
		return "", err
	}
	km, err := c.cc.GetChainClient().GetKeyManager()
	if err != nil {
		return "", err
	}
	privKey := km.String()
	txOpts, err := CreateTxOpts(context.Background(), c.ec, privKey, chainId, DefaultGasLimit, nonce)
	if err != nil {
		// return fmt.Errorf("failed to create tx opts")
		return "", err
	}

	session, err := CreateStorageSession(c.ec, *txOpts, StorageAddress)
	if err != nil {
		// return fmt.Errorf("failed to create session")
		return "", err
	}

	txRsp, err := session.CreateBucket(
		createBucketMsg.BucketName,
		uint8(createBucketMsg.Visibility),
		common.HexToAddress(createBucketMsg.PaymentAddress),
		common.HexToAddress(createBucketMsg.PrimarySpAddress),
		storage.Approval{
			ExpiredHeight:              createBucketMsg.PrimarySpApproval.ExpiredHeight,
			GlobalVirtualGroupFamilyId: createBucketMsg.PrimarySpApproval.GlobalVirtualGroupFamilyId,
			Sig:                        createBucketMsg.PrimarySpApproval.Sig,
		},
		createBucketMsg.ChargedReadQuota,
	)
	if err != nil {
		return "", err
	}
	return txRsp.Hash().String(), nil
}
